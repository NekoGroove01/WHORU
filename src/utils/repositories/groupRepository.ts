// src/repositories/groupRepository.ts
import { Collection, Document, ObjectId } from "mongodb";
import { connectToDatabase } from "@/utils/mongodb"; // Assuming mongodb.ts is in utils
import { GroupSchema, GroupSettingsSchema } from "@/utils/schema"; // For type inference
import { z } from "zod";

// Internal type for what's stored in DB. Dates are Date objects.
// MongoDB will have an _id of type ObjectId. We use a separate string 'id' field for nanoid.
export interface GroupDocument extends Document {
	_id: ObjectId; // MongoDB native ID
	id: string; // Our nanoid application ID
	name: string;
	description: string | null;
	isPublic: boolean;
	accessCode: string | null;
	qrCodeLink: string | null;
	createdAt: Date;
	updatedAt: Date;
	expiresAt: Date | null;
	settings: z.infer<typeof GroupSettingsSchema>;
	// tags will be managed via questions or a separate group-level tag concept
	memberCount: number;
	questionCount: number;
	lastActivityAt: Date;
	// We should store creatorTempId for ownership/admin purposes
	creatorTempId: string;
}

// Type for data being inserted (matches GroupDocument structure, _id is generated by Mongo)
export type GroupInsertData = Omit<
	GroupDocument,
	"_id" | "memberCount" | "questionCount"
> & {
	memberCount?: number;
	questionCount?: number;
};

// Helper to map MongoDB document to our API schema type (z.infer<typeof GroupSchema>)
// Ensure this helper is flexible about returning accessCode.
// For the user joining via access code, it's fine to return it.
// For public listings or other contexts, it might be omitted for private groups.
const mapDocumentToGroupSchema = (
	doc: GroupDocument,
	includeAccessCode: boolean = false
): z.infer<typeof GroupSchema> => {
	return {
		id: doc.id,
		name: doc.name,
		description: doc.description,
		isPublic: doc.isPublic,
		// Conditionally include accessCode
		accessCode: includeAccessCode || doc.isPublic ? doc.accessCode : undefined,
		qrCodeLink: doc.qrCodeLink,
		createdAt: doc.createdAt.toISOString(),
		updatedAt: doc.updatedAt.toISOString(),
		expiresAt: doc.expiresAt ? doc.expiresAt.toISOString() : null,
		settings: doc.settings,
		memberCount: doc.memberCount,
		questionCount: doc.questionCount,
		lastActivityAt: doc.lastActivityAt.toISOString(),
	};
};
export class GroupRepository {
	private async getCollection(): Promise<Collection<GroupDocument>> {
		const { db } = await connectToDatabase();
		return db.collection<GroupDocument>("groups");
	}

	async create(
		groupData: GroupInsertData
	): Promise<z.infer<typeof GroupSchema>> {
		const collection = await this.getCollection();
		const result = await collection.insertOne(groupData as GroupDocument); // Type assertion

		// Fetch the inserted document to get all fields including defaults and _id
		const newGroupDoc = await collection.findOne({ _id: result.insertedId });
		if (!newGroupDoc) {
			throw new Error("Failed to create or retrieve group after insertion.");
		}
		return mapDocumentToGroupSchema(newGroupDoc, true); // Pass true to include accessCode
	}

	// find by group id
	async findById(id: string): Promise<z.infer<typeof GroupSchema> | null> {
		const collection = await this.getCollection();
		const groupDoc = await collection.findOne({ id: id }); // Query by our nanoid 'id'
		return groupDoc
			? mapDocumentToGroupSchema(groupDoc, groupDoc.isPublic)
			: null;
	}

	// find all groups with pagination and sorting
	async findAllPublic(
		page: number,
		limit: number,
		sortBy: string,
		sortOrder: "asc" | "desc"
	): Promise<z.infer<typeof GroupSchema>[]> {
		const collection = await this.getCollection();
		const skip = (page - 1) * limit;
		const sortParams: { [key: string]: 1 | -1 } = {};
		sortParams[sortBy] = sortOrder === "asc" ? 1 : -1;

		const groupDocs = await collection
			.find({ isPublic: true })
			.sort(sortParams)
			.skip(skip)
			.limit(limit)
			.toArray();

		return groupDocs.map((doc) => mapDocumentToGroupSchema(doc, true)); // Pass true to include accessCode
	}

	async countAllPublic(): Promise<number> {
		const collection = await this.getCollection();
		return collection.countDocuments({ isPublic: true });
	}

	// Find a group by its access code
	async findByAccessCode(
		accessCode: string
	): Promise<z.infer<typeof GroupSchema> | null> {
		const collection = await this.getCollection();
		const groupDoc = await collection.findOne({ accessCode: accessCode });
		// If found by access code, the user provided it, so it's okay to return the full details including the access code itself.
		return groupDoc ? mapDocumentToGroupSchema(groupDoc, true) : null;
	}
}

export const groupRepository = new GroupRepository();
